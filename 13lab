/*пирамидальная сортировка
ринцип работы пирамидальной сортировки:
1. Построение начальной структуры кучи из массива данных. Это можно сделать, например, путем преобразования неотсортированного массива в кучу.
2. Перестановка корня кучи с последним элементом массива и уменьшение размера кучи.
3. Восстановление свойств кучи после каждой замены корня.
4. Повторение шагов 2 и 3 до тех пор, пока не останется только один элемент в куче.*/ 
#include <stdio.h>

// Функция для просеивания элемента вниз в куче
void heapify(int arr[], int n, int i) {
    int largest = i;  // Инициализируем наибольший элемент как корень
    int l = 2 * i + 1;  // Индекс левого дочернего элемента
    int r = 2 * i + 2;  // Индекс правого дочернего элемента

    // Если левый дочерний элемент существует и больше корня (Если значение левого дочернего элемента оказывается больше наибольшего элемента, то индекс наибольшего элемента обновляется на индекс левого дочернего элемента.)
    if (l < n && arr[l] > arr[largest])//сравнивает значение левого дочернего элемента с наибольшим из трех элементов: текущим узлом, левым дочерним элементом и правым дочерним элементом.
        largest = l;

    // Если правый дочерний элемент существует и больше корня или левого дочернего элемента
    if (r < n && arr[r] > arr[largest])//тоже самое только с правым дочерним корнем
        largest = r;

    // Если наибольший элемент не корень
    if (largest != i) {
        // Меняем местами корень и наибольший элемент
        int temp = arr[i];
        arr[i] = arr[largest];
        arr[largest] = temp;

        // Продолжаем просеивать вниз в направлении largest
        heapify(arr, n, largest);
    }
}

// Основная функция, выполняющая пирамидальную сортировку
void heapSort(int arr[], int n) {
    // Строим кучу (перегруппируем массив)
    for (int i = n / 2 - 1; i >= 0; i--)
        heapify(arr, n, i);

    // Извлекаем элементы из кучи по одному
    for (int i = n - 1; i > 0; i--) {
        // Перемещаем текущий корень в конец
        int temp = arr[0];
        arr[0] = arr[i];
        arr[i] = temp;

        // Вызываем процедуру просеивания на уменьшенной куче
        heapify(arr, i, 0);
    }
}

// Функция для печати массива
void printArray(int arr[], int n) {
    for (int i = 0; i < n; ++i)
        printf("%d ", arr[i]); // Вывод элементов массива
    printf("\n");
}

// Пример использования
int main() {
    int arr[] = {12, 11, 13, 5, 6, 7}; // Исходный массив
    int n = sizeof(arr) / sizeof(arr[0]); // Размер массива

    printf("Исходный массив:\n");
    printArray(arr, n); // Вывод исходного массива

    heapSort(arr, n); // Вызов функции пирамидальной сортировки

    printf("Отсортированный массив:\n");
    printArray(arr, n); // Вывод отсортированного массива

    return 0;
}
//Шейкерная сортировка
/*Шейкерная сортировка (также известная как двунаправленная сортировка) — разновидность пузырьковой сортировки.
В методе пузырьковой сортировки можно отметить два обстоятельства:
Если при движении по части массива перестановки не происходят, то эта часть массива уже отсортирована, и её можно исключить из рассмотрения.
При движении от конца массива к началу минимальный элемент «всплывает» на первую позицию, а максимальный элемент сдвигается только на одну позицию вправо.
Границы рабочей части массива (то есть части массива, где происходит движение) устанавливаются в месте последнего обмена на каждой итерации. Массив просматривается поочередно справа налево и слева направо.*/
#include <stdio.h>

// Функция для выполнения шейкерной сортировки
void cocktailSort(int arr[], int n) {
    int swapped = 1; // Флаг, указывающий, были ли сделаны обмены на текущей итерации
    int start = 0; // Индекс начала подмассива
    int end = n - 1; // Индекс конца подмассива

    // Пока есть элементы для обмена
    while (swapped) {
        swapped = 0; // Сбрасываем флаг обмена

        // Проходим слева направо
        for (int i = start; i < end; ++i) {
            if (arr[i] > arr[i + 1]) {
                // Обмен значениями
                int temp = arr[i];
                arr[i] = arr[i + 1];
                arr[i + 1] = temp;
                swapped = 1; // Устанавливаем флаг обмена
            }
        }

        // Если не было обменов, массив уже отсортирован
        if (!swapped)
            break;

        swapped = 0; // Сбрасываем флаг обмена

        // Сдвигаем end на один элемент назад, так как самый большой элемент уже находится в конце
        --end;

        // Проходим справа налево
        for (int i = end - 1; i >= start; --i) {
            if (arr[i] > arr[i + 1]) {
                // Обмен значениями
                int temp = arr[i];
                arr[i] = arr[i + 1];
                arr[i + 1] = temp;
                swapped = 1; // Устанавливаем флаг обмена
            }
        }

        // Сдвигаем start на один элемент вперед, так как самый маленький элемент уже находится в начале
        ++start;
    }
}

// Функция для печати массива
void printArray(int arr[], int size) {
    for (int i = 0; i < size; i++)
        printf("%d ", arr[i]);
    printf("\n");
}

// Функция main для тестирования шейкерной сортировки
int main() {
    int arr[] = {5, 1, 4, 2, 8, 0, 2}; // Исходный массив
    int n = sizeof(arr) / sizeof(arr[0]); // Размер массива

    printf("Исходный массив:\n");
    printArray(arr, n); // Вывод исходного массива

    cocktailSort(arr, n); // Вызов функции сортировки

    printf("Отсортированный массив:\n");
    printArray(arr, n); // Вывод отсортированного массива

    return 0;
}
//Сортировка включением
/*Если следующее значение больше предыдущего элемента, то значение переходит в правую часть элемента.
В противном случае оно перемещается в левую часть элемента.*/
#include <stdio.h>

// Функция для сортировки вставками
void insertionSort(int arr[], int n) {
    int i, key, j;//временное хранение значений.
    for (i = 1; i < n; i++) {
        key = arr[i]; // Значение текущего элемента масиива в key
        j = i - 1;//Установка переменной j, чтобы она указывала на предыдущий элемент от текущего элемента.

        // Перемещаем элементы arr[0..i-1], которые больше, чем key, на одну позицию вперед от их текущего положения
        while (j >= 0 && arr[j] > key) {//пока j больше или равно 0 и элемент массива arr[j] больше key
            arr[j + 1] = arr[j]; // Перемещаем элемент на одну позицию вперед
            j = j - 1;
        }
        arr[j + 1] = key; // Вставляем key в отсортированную последовательность
    }
}

// Функция для печати массива
void printArray(int arr[], int n) {
    int i;
    for (i = 0; i < n; i++)
        printf("%d ", arr[i]); // Вывод элементов массива
    printf("\n");
}

// Функция main для тестирования сортировки вставками
int main() {
    int arr[] = {12, 11, 13, 5, 6}; // Исходный массив
    int n = sizeof(arr) / sizeof(arr[0]); // Размер массива

    printf("Исходный массив:\n");
    printArray(arr, n); // Вывод исходного массива

    insertionSort(arr, n); // Вызов функции сортировки вставками

    printf("Отсортированный массив:\n");
    printArray(arr, n); // Вывод отсортированного массива

    return 0;
}
