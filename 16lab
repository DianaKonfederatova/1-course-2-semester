#include <stdio.h>
#include <stdlib.h>//работа с динрамической памятью
//Определение структуры узла Node
typedef struct Node {//typedef-дает имя, теперь можно обращаться Node, а не struct Node
    struct Node* nextList;//объявление указателя nextList типа struct Node* внутри структуры Node, который указывает на следующий узел в списке.
    int data;//переменная для хранения узлов              
    struct Node* nextNode;//объявление указателя nextNode типа struct Node* внутри структуры Node, который указывает на следующий узел в другом списке.
} Node;//завершение определения структуры Node и создание типа Node.

//Добавление нового узла в односвязный список
Node* addNode(Node* head, int data, Node** tail) {//указатель на голову списка head, данные для нового узла data и указатель на указатель на хвост списка tail. Возвращает указатель на голову списка после добавления нового узла
    Node* newNode = (Node*)malloc(sizeof(Node));//Выделяет память под новый узел с помощью функции malloc. Приводит указатель к типу Node* и присваивает его переменной newNode
    newNode->data = data;//Присваивает данные data новому узлу
    newNode->nextNode = NULL;//Устанавливает указатель на следующий узел в текущем списке в NULL.
    newNode->nextList = NULL;// Устанавливает указатель на следующий узел в другом списке в NULL.

    if (head == NULL) {//Проверяет, является ли список пустым
        *tail = newNode;//Если список пуст, устанавливает хвост списка на новый узел.
        return newNode;//возвращает указатель на новый узел.
    } else {
        (*tail)->nextNode = newNode;//Устанавливает указатель на следующий узел для текущего хвоста списка на новый узел.
        *tail = newNode;//Обновляет указатель хвоста списка на новый узел.
        return head;//Возвращает указатель на голову списка (не изменился)
    }
}
//Добавление нового узла с данными data в односвязный список.
Node* addNodeS(Node* head, int data, Node** tail) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->data = data;
    newNode->nextNode = NULL;
    newNode->nextList = NULL;

    if (head == NULL) {
        *tail = newNode;
        return newNode;
    } else {
        newNode->nextList=*tail;//Устанавливает указатель на следующий узел в другом списке для нового узла, указывающий на предыдущий хвост списка.
        *tail = newNode;//Обновляет указатель хвоста списка на новый узел. 
        return head;//Возвращает указатель на голову списка (не изменился)
    }
}
//проход по связному списку,
void printList(Node* head) {//printList-печать списка, указатель на начало списка
    Node* current = head;//создается указатель current типа Node* и инициализируется указателем head. Этот указатель используется для перемещения по связному списку.
    while (current != NULL) {//Это начало цикла while, который продолжается до тех пор, пока current не станет NULL
        printf("%d ", current->data);//вызывает функцию printf для вывода данных, хранящихся в текущем узле списка. current->data обращается к полю data структуры Node, на которую указывает current
        current = current->nextNode;//после вывода данных, эта строка перемещает указатель current на следующий узел в списке, используя поле nextNode структуры Node.
    }
    printf("\n");//вывода символа новой строки \n, чтобы перейти к следующей строке в консоли.
}

void freeList(Node* head) {
    Node* temp;// указатель temp на структуру Node.
    while (head != NULL) {//продолжается, пока указатель head не станет NULL.
        temp = head;//Присваиваем указателю temp значение указателя head. Таким образом, temp теперь указывает на тот же узел списка, на который указывает head
        head = head->nextNode;//Обновляем указатель head, чтобы он указывал на следующий узел списка.
        free(temp);//Освобождаем память, выделенную для узла, на который указывает temp
    }
}

int main() {
    Node* firstList = NULL; //создание указателя на первый список
    Node* secondList = NULL; //создание указателя на второй список
    Node *firstTail = NULL, *secondTail = NULL;//объявляются два указателя на узлы Node
    Node* S = NULL;//указатель на s, ссылочная переменная
    int data, count = 0;//data-данные cout-считать

    printf("Введите последовательность чисел (0 для окончания ввода)\n");
    while (1) {
        scanf("%d", &data);//считывает целое число, введенное пользователем, и сохраняет его в переменной data.
        if (data == 0) break;//Если введенное число равно 0, то происходит выход из цикла.

        count++;//Увеличивает счетчик count на 1 на каждой итерации, чтобы отслеживать количество введенных чисел.
        if (count % 2 == 1) {//Если count нечетное число, выполняется блок кода, добавляющий число в первый список
            firstList = addNode(firstList, data, &firstTail);//Вызывается функция addNode, которая добавляет новый узел с числом data в конец первого списка firstList.
            if (S == NULL) {S = firstList;firstTail->nextList=NULL;}//Если список S пустой, то он ссылается на первый список, а последний элемент первого списка указывает на NULL
        } else {//Если число введено не для первого списка
            secondList = addNodeS(secondList, data, &secondTail);//Вызывается функция addNodeS, которая добавляет новый узел с числом data в конец второго списка secondList
            if (count==2) secondTail->nextList=firstList;//Если второе число введено (count == 2), то второй список указывает на первый список.
            else firstTail->nextList=secondTail;//В противном случае последний элемент первого списка указывает на последний элемент второго списка.
            
        }
    }
//проверка наличия последнего элемента (tail)
//если какие-то элементы добавлялись как в первый, так и во второй список, то после выполнения этой строки будет создана связь между последним элементом первого списка и последним элементом второго списка, что позволяет объединить их в одну последовательность
    if (firstTail && secondTail) {
        firstTail->nextList = secondTail;//Эта строка устанавливает указатель на следующий элемент первого списка (nextList), который указывает на последний элемент второго списка, что связывает два списка вместе.
    }

    printf("Первый список:\n");
    printList(firstList);
    
    printf("Второй список:\n");
    printList(secondList);

    printf("Нажмите «а», чтобы пойти налево, и «d», чтобы пойти направо. Любой другой ключ для выхода\n");
    Node *lst_ptr = firstList;//объявляет указатель lst_ptr и инициализирует его значением firstList.
    Node* Snd_ptr = secondList;
    char c;
    getchar();// считывает символ из стандартного ввода
    while(1) {
        char key = 'f';//объявляет переменную key и инициализирует ее значением 'f'

        printf("Value: %d; Addr prev: %p next: %p\n", lst_ptr->data, lst_ptr->nextList, lst_ptr->nextNode);//выводит значение узла списка, а также адреса предыдущего и следующего узлов.
        scanf("%c%*c", &key);// считывает символ с клавиатуры и сохраняет его в переменную key.
        

        printf("Ключ введен: '%c'\n", key);
        if (key == 'a') {//сли введен символ 'a' и у текущего узла есть ссылка на предыдущий узел (nextList), то переходим к предыдущему узлу.
            if (lst_ptr->nextList)
                lst_ptr = lst_ptr->nextList;
            else 
                printf("Невозможно сюда зайти: предыдущее значение равно NULL\n");
            
        } else if(key == 'd') {//Если введен символ 'd' и у текущего узла есть ссылка на следующий узел (nextNode), то переходим к следующему узлу.
            if (lst_ptr->nextNode)
                lst_ptr = lst_ptr->nextNode;
            else
                printf("Сюда нельзя: дальше NULL\n");

        } else {
            printf("Выход..\n");
            break;
        }
    }

    freeList(firstList);//освобождают выделенную память для обоих списков.
    freeList(secondList);

    return 0;
}
//В результате данная программа позволяет пользователю перемещаться по двунаправленному списку, выбирая направление движения с помощью клавиш 'a' и 'd' или завершая работу программы любым другим введенным символом.
